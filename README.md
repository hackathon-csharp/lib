# datapacklib

Протокол и библиотека для преобразования произвольных массивов байтов в переходы `SignalChange` и обратно. Решение рассчитано на передачу через ИК-светодиод/приёмник и умеет обнаруживать ошибки, пропуски и несоответствие кадров.

## Почему это надёжно

- Каждый кадр начинается преамбулой (длинный импульс + пауза) с магическим номером `0xC39A` и завершается эндером `0x51AA`.
- Заголовок содержит версию протокола, длину полезной нагрузки и CRC16-CCITT по полезным данным.
- Цветовая четырёхуровневая модуляция: один цвет несёт 2 бита (`00` — красный, `01` — зелёный, `10` — синий, `11` — белый). Между символами всегда идёт «выключенное» состояние, что облегчает выравнивание даже при пропусках.
- Декодер ведёт подробную статистику ошибок (CRC, некорректные длительности, неожиданные маркеры).

## Формат кадра

| Поле                | Размер (байт) | Описание                                      |
|---------------------|---------------|-----------------------------------------------|
| Magic               | 2             | `0xC39A` — позволяет быстро выровнять поток  |
| Version             | 1             | Текущая версия (по умолчанию `1`)             |
| Payload Length      | 2             | Длина полезных данных                         |
| CRC16-CCITT         | 2             | Контрольная сумма полезной нагрузки           |
| Payload             | N             | Пользовательские данные                       |
| Ender               | 2             | `0x51AA` — окончание кадра                    |

По умолчанию единичный временной «тик» — 600 мкс. Преамбула: 16 тиков белого света и 8 тиков паузы. Каждый цветовой импульс длится 1 тик, разделители (выключенный свет) — 1 тик, а после кадра автоматически добавляется «тишина» на 12 тиков.

## Использование

```cpp
#include "datapacklib.h"

using namespace datapack;

Encoder encoder;
Decoder decoder(
	[](const std::vector<std::uint8_t>& payload) {
		// обработка полезных данных
	});

auto signal = encoder.encode(payloadBytes);
for (const auto& change : signal)
{
	decoder.feed(change);
}
```

Декодер можно создавать один раз и вызывать `feed` при каждом наблюдаемом изменении уровня (значение и длительность в микросекундах). Когда кадр успешно собран, вызывается переданный коллбэк.

## Сборка примера

```bash
g++ -std=c++17 -Wall -Wextra example.cpp datapacklib.cpp -o datapack_demo
./datapack_demo
```

## Настройка протокола

`ProtocolConfig` позволяет менять длительности импульсов, допуск, макс. длину полезной нагрузки, magic/ender и т.д. Все проверки выполняются как на стороне энкодера (бросает исключение при слишком длинном payload), так и на стороне декодера.
